import ETK.ETKUnit as Unit;
import ETK.ETKUtils as Utils;
import ETK.ETKTimer as Timer;
import ETK.ETKConstants as Const;
import ETK.ETKCommon as Common;
import Balance;
import Waves;
import Upgrades;
import CommandCard;

const TowerUnitType = Const.Unit_TerranBeacon;
const TOWERS = EUDArray(64);
const TOWER_UNITS = EUDArray(1024);
var TOWER_COUNT = 0;
const Screen = StringBuffer(256);
var fntil = 0;

// UTILS; MOVE

function findNewTargetInLocation(location, playerID) {
    fntil++;
    setcurpl(P1); Screen.printfAt(4, "findNewTargetInLocation {}", fntil);

    var targetUnit = 0;
    var lowestHP = 0;
    var longestTimeOnMap = 0;
    foreach(ptr, unit : EUDLoopPlayerUnit(playerID)) {
        if (Utils.CUnitInLocationPadded(unit, location, 128)) {
            const unitAge = Unit.getKillCount(unit);
            if (targetUnit == 0 || unitAge > longestTimeOnMap) {
                longestTimeOnMap = unitAge;
                targetUnit = unit;
                const hp = Unit.getHitpoints(unit);
                if (targetUnit == 0 || hp < lowestHP) {
                    lowestHP = hp;
                    targetUnit = unit;
                }
            }
        }
    }
    return targetUnit;
}

object Offset {
    var x;
    var y;
};

function MakeOffset(x, y) : Offset {
    const offset = Offset.alloc();
    offset.x = x; 
    offset.y = y; 
    return offset;
}

object Image {
    var id;
    var x;
    var y;
    // var drawFunction
    // var drawWhenCloaked
    // var iscriptHeader
    // function drawAtPoint(x, y);
    // function drawAtUnit(x, y);
    // function drawAtLocaton(x, y);
};

function MakeImage(imageID, x, y) : Image {
    const image = Image.alloc();
    image.id = imageID;
    image.x = x; 
    image.y = y; 
    return image;
}

const TOWER_TYPES = EUDArray(64);

object TowerData {
    var baseDamage;
    var baseSpeed;
    var baseRange;
};

function CreateTowerData(baseDamage, baseRange, baseSpeed) : TowerData {
    const data = TowerData.alloc();
    data.baseDamage = baseDamage;
    data.baseSpeed = baseSpeed;
    data.baseRange = baseRange;
    return data;
}

object TowerImageData {
    var spriteImage : Image;
    var missileSpawnImage : Image;
    var missileImage : Image;
    var hitImage : Image;
};

function CreateTowerImageData(spriteImage, missileSpawnImage, missileImage, hitImage) : TowerImageData {
    const data = TowerImageData.alloc();
    data.spriteImage = spriteImage;
    data.missileSpawnImage = missileSpawnImage;
    data.missileImage = missileImage;
    data.hitImage = hitImage;
    return data;
}

object TowerType {
    var id;
    var data : TowerData;
    var imageData : TowerImageData;
    var fire: EUDFuncPtr (1, 0);
    var hit: EUDFuncPtr (3, 0);
};

function CreateTowerType(id, data: TowerData, imageData: TowerImageData) : TowerType {
    const towerType = TowerType.alloc();
    towerType.data = data;
    towerType.imageData = imageData;
    towerType.id = id;
    TOWER_TYPES[id] = towerType;
    return towerType;
}

object Tower {
    var unit;
    var type : TowerType;
    var currentUpgradeOptionSet : Upgrades.TowerUpgradeOptionSet;
    var damage;
    var range;
    var speed;
    var fireTimer;

    function applyUpgrade(upgrade) {
        if (upgrade == 0) {
            return;
        }
        const upgradeObject = Upgrades.TowerUpgrade.cast(upgrade);
        // setcurpl(P1); Screen.printf("applyUpgrade {:s} DSR: {} {} {}",
        //     upgradeObject.tooltip,
        //     upgradeObject.attributes[Upgrades.Damage],
        //     upgradeObject.attributes[Upgrades.Speed],
        //     upgradeObject.attributes[Upgrades.Range]
        // );
        this.damage += upgradeObject.attributes[Upgrades.Damage];
        this.speed += upgradeObject.attributes[Upgrades.Speed];
        this.range += upgradeObject.attributes[Upgrades.Range];
        this.currentUpgradeOptionSet = upgradeObject.nextSet;
    }

    function update() {
        this.fireTimer++;
    }

    function sell() {
        const cannonUnit = Unit.getConnectedUnit(this.unit);
        Utils.removeUnit(this.unit);
        Utils.removeUnitSafe(cannonUnit);
    }

    function handleButtonClick() {
        if (this.unit == 0 || this.currentUpgradeOptionSet == 0) {
            return;
        }
        const button = CommandCard.getButtonIndexFromBuildQueue(this.unit);
        // setcurpl(P1); Screen.printf("handleButtonClick {}", button);
        switch(button) {
            case 0: this.applyUpgrade(this.currentUpgradeOptionSet.optionA); break;
            case 1: this.applyUpgrade(this.currentUpgradeOptionSet.optionB); break;
            case 2: this.applyUpgrade(this.currentUpgradeOptionSet.optionC); break;
            case 8: this.sell(); break;
        }
    }

    function updateInterface(playerID) {
        if (this == 0) {
            return;
        }
        if (IsUserCP()) {
            const weaponID = 229 + playerID;
            settblf(weaponID, 0, "Speed: {}\nRange: {}", this.speed, this.range);
            Utils.setWeaponDamage(playerID, this.damage);
            // Utils.setWeaponIcon(weaponID, ...);
            Utils.setUnitWeapon(TowerUnitType, playerID);

            if (this.currentUpgradeOptionSet == 0) {
                CommandCard.hideAllButtonIcons();
            } else {
                CommandCard.hideAllButtonIcons();
                CommandCard.setButtonIcon(0, this.currentUpgradeOptionSet.optionA.icon, this.currentUpgradeOptionSet.optionA.tooltip);
                CommandCard.setButtonIcon(1, this.currentUpgradeOptionSet.optionB.icon, this.currentUpgradeOptionSet.optionB.tooltip);
                CommandCard.setButtonIcon(2, this.currentUpgradeOptionSet.optionC.icon, this.currentUpgradeOptionSet.optionC.tooltip);
                CommandCard.setButtonIcon(8, Const.Icon_ReturnResources, Common.EmptyString);
            }
        }
    }
};

function CreateTower(type : TowerType, towerUnit) : Tower {
    const tower = Tower.alloc();
    tower.unit = towerUnit;
    tower.type = type;
    tower.damage += type.data.baseDamage;
    tower.speed += type.data.baseSpeed;
    tower.range += type.data.baseRange; 
    Unit.setUnknown00(towerUnit, tower);
    return tower;
}

function getTowerForUnit(unitPointer) : Tower {
    const towerObj = Unit.getUnknown00(unitPointer);
    if (towerObj == 0) {
        return 0;
    }
    return Tower.cast(towerObj);
}

function getTowerTypeByID(id): TowerType {
    return TOWER_TYPES[id];
}

function getUnitTowerTypeID(towerUnit) {
    return Unit.getCustomValue(towerUnit);
}

function setUnitTowerTypeID(towerUnit, value) {
    Unit.setCustomValue(towerUnit, value);
}

function isUnitTower(unit) {
    if (unit == 0) {
        return false;
    }
    if (Unit.getUnitType(unit) == TowerUnitType) {
        return true;
    }
    return false;
}

function isUnitBaseTower(towerUnit) {
    if (!isUnitTower(towerUnit)) {
        return false;
    }
    if (getUnitTowerTypeID(towerUnit) == 0) {
        return true;
    }
    return false;
}

function isUnitUpgradedTower(towerUnit) {
    if (!isUnitTower(towerUnit)) {
        return false;
    }
    if (getUnitTowerTypeID(towerUnit) > 0) {
        return true;
    }
    return false;
}

function getTowerTypeFromUnit(towerUnit): TowerType {
    return TOWER_TYPES[Unit.getCustomValue(towerUnit)];
}

function isTowerTypeValid(id) {
    return getTowerTypeByID(id) != 0 && id < TOWER_COUNT;
}

function getTowerTarget(towerUnit) {
    return Unit.getUnknown04(towerUnit);
}

function setTowerTarget(towerUnit, targetUnit) {
    Unit.setUnknown04(towerUnit, targetUnit);
}

function resetTowerTarget(towerUnit) {
    setTowerTarget(towerUnit, 0);
}

function sellTower(towerUnit) {
    const cannonUnit = Unit.getConnectedUnit(towerUnit);
    Utils.removeUnit(towerUnit);
    Utils.removeUnitSafe(cannonUnit);
}

function createBaseTower(location, playerID) {
    const towerUnit = Utils.createUnit(TowerUnitType, $L("SafeCreate"), $P8);
    MoveUnit(1, TowerUnitType, $P8, $L("SafeCreate"), location);
    if (Bring($P8, AtLeast, 1, TowerUnitType, $L("SafeCreate"))) {
        RemoveUnitAt(1, TowerUnitType, $L("SafeCreate"), $P8);
        eprintln("You can't build there.");
    } else {
        GiveUnits(1, TowerUnitType, $P8, location, playerID);
    }
    Unit.setCommandCard(towerUnit, Const.Unit_TerranFlagBeacon);
}

function drawTowerRange(x, y, range) {
    Utils.moveUtilLocationToPoint(x, y);

    const lx1 = x - range;
    const lx2 = x + range;
    const ly1 = y - range;
    const ly2 = y + range;

    Utils.createImageSpriteAtPoint(Const.Image_Nuke_Target_Dot, lx1, ly1);
    Utils.createImageSpriteAtPoint(Const.Image_Nuke_Target_Dot, lx2, ly1);
    Utils.createImageSpriteAtPoint(Const.Image_Nuke_Target_Dot, lx1, ly2);
    Utils.createImageSpriteAtPoint(Const.Image_Nuke_Target_Dot, lx2, ly2);
}

function setTowerType(towerUnit, towerID) {
    // Make sure to clear any previous cannon unit if available
    Utils.removeUnit(Unit.getConnectedUnit(towerUnit));
    const towerType = getTowerTypeByID(towerID);
    const tower = CreateTower(towerType, towerUnit);
    setUnitTowerTypeID(towerUnit, towerID);

    const playerID = Unit.getPlayerID(towerUnit);
    Utils.moveUtilLocationToUnit(towerUnit);
    const cannonSpriteID = 487;
    const cannonImageID = towerType.imageData.spriteImage.id;
    Utils.setImageDrawFunction(cannonImageID, 1);
    Utils.setImageClickable(cannonImageID, 0);
    Utils.setSpriteImage(cannonSpriteID, cannonImageID);
    const cannonUnit = Utils.createUnitAtLocationWithOffset(Const.Unit_ProtossCorsair, Utils.UTILITY_LOCATION, $P8, towerType.imageData.spriteImage.x, towerType.imageData.spriteImage.y);
    Utils.setUnitColor(cannonUnit, playerID);
    Unit.setStatusFlags(cannonUnit, 0x04240201);
    Unit.setConnectedUnit(towerUnit, cannonUnit);

    Unit.setCustomValue(towerUnit, towerType.id);
    Unit.setRankIncrease(towerUnit, 0);
    // Unit.setCommandCard(towerUnit, TowerUnitType);
    tower.currentUpgradeOptionSet = Upgrades.Set1;
    CommandCard.setupUnit(towerUnit);

    Utils.refreshInterface();
    resetTowerTarget(towerUnit);
}

function towerFire(towerUnit) {
    const cannonUnit = Unit.getConnectedUnit(towerUnit);
    const towerType = getTowerTypeByID(Unit.getCustomValue(towerUnit));
    const targetUnit = getTowerTarget(towerUnit);

    if (towerType.imageData.missileImage.id != Const.Image_None) {
        Utils.setSpriteImage(202, towerType.imageData.missileImage.id);
        Utils.setImageDrawFunction(towerType.imageData.missileImage.id, 1);
        Utils.setImageDrawIfCloaked(towerType.imageData.missileImage.id, 1);
    } else {
        Utils.setSpriteImage(202, Const.Image_Observer);
        Utils.setImageDrawFunction(towerType.imageData.missileImage.id, 0);
        Utils.setImageDrawIfCloaked(Const.Image_Observer, 0);
    }

    if (towerType.fire != 0) {
        towerType.fire(towerUnit);
    }

    const direction = Utils.getDirectionFromPosition32(towerUnit, Unit.getPositionX(targetUnit), Unit.getPositionY(targetUnit));
    Utils.moveUtilLocationToUnit(towerUnit);
    Utils.setUnitInitialDirection(Const.Unit_ProtossObserver, direction);
    const missileUnit = Utils.createUnitAtLocationWithOffset(Const.Unit_ProtossObserver, Utils.UTILITY_LOCATION, $P8, towerType.imageData.missileImage.x, towerType.imageData.missileImage.y);
    // Unit.setStatusFlags(missileUnit, 0x04250205);
    Utils.setUnitColor(missileUnit, Unit.getPlayerID(towerUnit));

    if (towerType.imageData.missileSpawnImage.id != Const.Image_None) {
        Utils.createImageSpriteAtUnitPosition(towerType.imageData.missileSpawnImage.id, cannonUnit);
    }
    Unit.setConnectedUnit(missileUnit, towerUnit);
    Unit.setOrder(missileUnit, Const.Order_Ignore_Normal);
    Unit.setTargetUnit(missileUnit, targetUnit);
}

function updateTower(towerUnit) {
    if (isUnitBaseTower(towerUnit)) {
        return;
    }

    const tower = getTowerForUnit(towerUnit);
    if (tower == 0) {
        return;
    }
    const enemyPlayerID = $P7;
    const towerType = getTowerTypeFromUnit(towerUnit);
    const towerRange = tower.range; //TODO: towerData.calculateRange();
    const targetUnit = getTowerTarget(towerUnit);

    if (targetUnit == 0 && Unit.getGroundWeaponCooldown(towerUnit) == 0) {
        // Check if there are enemy units nearby and target a new unit
        Utils.centerLocationOnUnit(Utils.LOCATION_ANYSIZE, towerUnit, towerRange * 2, towerRange * 2);
        Utils.refreshLocations();
        if (Bring(enemyPlayerID, AtLeast, 1, Const.Unit_AnyUnit, Utils.LOCATION_ANYSIZE)) {
            const enemyUnit = findNewTargetInLocation(Utils.LOCATION_ANYSIZE, enemyPlayerID );
            // setcurpl(P1); Screen.printAt(5, "Bring");
            if (enemyUnit != 0) {
                // setcurpl(P1); Screen.printAt(6, "setTargetUnit");
                setTowerTarget(towerUnit, enemyUnit);
                // Unit.setOrder(towerUnit, Const.Order_Attack_Building);
            } else {
                // setcurpl(P1); Screen.printAt(6, "Notfound");
            }
        }
    } else {
        // Check if target is still within range, otherwise clear it and target a new unit
        Utils.centerLocationOnUnit(Utils.LOCATION_ANYSIZE, towerUnit, towerRange * 2, towerRange * 2);
        Utils.refreshLocations();
        if (!Utils.bringUnit(targetUnit, Utils.LOCATION_ANYSIZE)) {
            resetTowerTarget(towerUnit);
            // Unit.setOrder(towerUnit, Const.Order_Nothing1_Unused);
            // setcurpl(P1); Screen.printAt(3, "No bring - clearTarget");
        }
    }

    //Firing
    if (Unit.getGroundWeaponCooldown(towerUnit) > towerType.data.baseSpeed) {
        Unit.setGroundWeaponCooldown(towerUnit, towerType.data.baseSpeed);       
    }

    if (Unit.getGroundWeaponCooldown(towerUnit) == 0
        && getTowerTarget(towerUnit) != 0) {
        towerFire(towerUnit);
        Unit.setGroundWeaponCooldown(towerUnit, towerType.data.baseSpeed);   
    }
}

function missileHit(missileUnit) {
    const targetUnit = Unit.getTargetUnit(missileUnit);
    const towerUnit = Unit.getConnectedUnit(missileUnit);
    const tower = getTowerForUnit(towerUnit);
    const targetUnitType = Unit.getUnitType(targetUnit);
    const towerType = getTowerTypeFromUnit(towerUnit);
    if (towerType.imageData.hitImage.id != Const.Image_None) {
        Utils.createImageSpriteAtUnitPosition(towerType.imageData.hitImage.id, targetUnit);
    }
    const damage = tower.damage;

    if (towerType.hit != 0) {
        towerType.hit(towerType, missileUnit, targetUnit);
    }
    const createLocationX = Unit.getPositionX(targetUnit);
    const createLocationY = Unit.getPositionY(targetUnit);
    const targetUnitX = Unit.getOrderTargetX(targetUnit);
    const targetUnitY = Unit.getOrderTargetY(targetUnit);
    const targetUnitPriority = Unit.getKillCount(targetUnit);
    if (Unit.damage(targetUnit, damage)) {
        SetResources(Unit.getPlayerID(towerUnit), 8, Utils.getUnitDestroyValue(targetUnitType), 0);
        const data = [targetUnitType, targetUnitX, targetUnitY, targetUnitPriority, targetUnit, createLocationX, createLocationY];
        Timer.add(6, data, EUDFuncPtr (2, 0) (function(data, intervalCount) {
            for (var i = 0; i < 2; i++) {
                const unitType = Waves.GetNextUnitType(targetUnitType);
                if (unitType != Const.Unit_None) {
                    const unitData = EUDArray.cast(data);
                    const targetUnitType = unitData[0];
                    const targetUnitX = unitData[1];
                    const targetUnitY = unitData[2];
                    const targetUnitPriority = unitData[3];
                    const targetUnit = unitData[4];
                    const createLocationX = unitData[5];
                    const createLocationY = unitData[6];
                    // Create unit offscreen
                    const unit = Utils.createUnit(unitType, Utils.OFFSCREEN_LOCATION, $P7);
                    Unit.setStatusFlags(unit, 0x00230005); // 5xxxx does not move
                    Utils.moveUnit(unit, Utils.moveUtilLocationToPoint(createLocationX, createLocationY));
                    Unit.setKillCount(unit, targetUnitPriority);
                    Unit.orderToPoint(unit, targetUnitX, targetUnitY);
                }
            }
        }));
        
    }
    Utils.removeUnit(missileUnit);
}

function load() {

    const t1 = CreateTowerType(1,
        CreateTowerData(100, 32*3, 100),
        CreateTowerImageData(
            MakeImage(Const.Image_STA_STS_Photon_Cannon_Overlay, 6, -12),
            MakeImage(Const.Image_None, 0, 0),
            MakeImage(Const.Image_Phase_Disruptor, 0, -16),
            MakeImage(Const.Image_Phase_Disruptor_Hit, 0, 0)
        )
    );

    const t2 = CreateTowerType(2,
        CreateTowerData(5, 32*6, 12*1),
        CreateTowerImageData(
            MakeImage(Const.Image_Maelstrom_Overlay_Small, 0, -16),
            MakeImage(Const.Image_None, 0, 0),
            MakeImage(Const.Image_Burst_Lasers_Hit, 0, -16),
            MakeImage(Const.Image_Yamato_Gun_Hit, 0, 0)
        )
    );
    t2.hit = EUDFuncPtr (3, 0) (function(towerType, missileUnit, targetUnit) {
        Utils.createOverlayForUnit(targetUnit, Const.Image_Flames2_Type3_Small, 64);
        Unit.setPlagueTimer(targetUnit, 64);
    });

    const t3 = CreateTowerType(3,
        CreateTowerData(1, 32*2, 12*1),
        CreateTowerImageData(
            MakeImage(Const.Image_Khalis, 0, -16),
            MakeImage(Const.Image_None, 0, 0),
            MakeImage(Const.Image_Hallucination_Death3, 0, 0),
            MakeImage(Const.Image_None, 0, 0)
        )
    );
    t3.hit = EUDFuncPtr (3, 0) (function(towerType, missileUnit, targetUnit) {
        const slowSpeed = 100;//Unit.getOriginalTopSpeed(targetUnit) / 10;
        if ( Unit.getTopSpeed(targetUnit) == slowSpeed) {
            return;
        }
        const duration = 64;
        Unit.setTopSpeed(targetUnit, slowSpeed);
        Utils.createOverlayForUnit(targetUnit, Const.Image_Acid_Spores_6_9_Overlay_Small, duration);
        Timer.add(duration, targetUnit, EUDFuncPtr (2, 0) (function(callbackUnit, intervalCount) {
            Unit.restoreOriginalTopSpeed(callbackUnit);
        }));
    });

    const t4 = CreateTowerType(5,
        CreateTowerData(1, 32*2, 12*1),
        CreateTowerImageData(
            MakeImage(Const.Image_Doodad_9_5_Jungle, -12, 0),
            MakeImage(Const.Image_None, 0, 0),
            MakeImage(Const.Image_None, 0, 0),
            MakeImage(Const.Image_None, 0, 0)
        )
    );

}