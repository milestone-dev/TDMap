import ETK.ETKUnit as Unit;
import ETK.ETKUtils as Utils;
import ETK.ETKTimer as Timer;
import ETK.ETKConstants as Const;
import ETK.ETKCommon as Common;
import Balance;
const Screen = StringBuffer(64);

const MobCountMultiplierConstant = 1000;
const SpawnDurationConstant = 600;


var CurrentWaveID;
var CurrentWaveSpawnTimer = 0;
var CurrentWaveSpawnTimerIncrement = 0;
var CurrentWave = EUDArray(7);
var CurrentWaveReward = 0;
var SpawnCooldown;

const UseTestWave = false;
const TestWave = [0,0,0,0,0,0,1];

// TODO Extend to all players, move to a point system.
const SpawnLocations = [
	$L("P1Track1")
];

function CalculateCurrentWaveRemainingMobs() {
	var num = 0;
	const waves = EUDArray.cast(CurrentWave);
	for (var i = Balance.TIER_COUNT; i > 0; i--) {
		num += waves[i];
	}
	return num;
}

function KillAllMobs() {
	RemoveUnit(Const.Unit_AnyUnit, P7);
}

function StartWave(waveID) {
	CurrentWaveID = waveID;
	KillAllMobs();
	if (waveID > 0) {
        SetResources(AllPlayers, SetTo, waveID, 1);
		// TODO Make sure array is copied, otherwise you can't replay the same wave twice
		CurrentWave = Balance.CalculateMobsForWave(CurrentWaveID); 
		if (UseTestWave) {
			CurrentWave = TestWave;
			// CurrentWave = EUDArray.cast(CurrentWave);
			const CurrentWaveArr = EUDArray.cast(CurrentWave);
			CurrentWaveArr[6] = 1;
		}
		CurrentWaveSpawnTimer = MobCountMultiplierConstant;
		const remainingMobs = CalculateCurrentWaveRemainingMobs();
		CurrentWaveReward = remainingMobs;
		CurrentWaveSpawnTimerIncrement = remainingMobs * MobCountMultiplierConstant / SpawnDurationConstant;
		setcurpl(P1); Screen.printf("Starting Wave {} r: {} ", waveID, CurrentWaveReward);
		if (remainingMobs == 0) {
			setcurpl(P1); Screen.printf("Error: Wave is empty: {}", waveID);
			CurrentWaveID = 0;
		}
	}
}

function GoToNextWave() {
    SetResources(AllPlayers, Add, CurrentWaveReward, 0);
	setcurpl(P1); Screen.printf("Wave completed! Adding {} minerals.", CurrentWaveReward);
    CurrentWaveReward = 0;
	StartWave(CurrentWaveID+1);
}

function GetUnitTypeForTier(tier) {
	switch(tier) {
	    case 1: return Const.Unit_ZergZergling; break;
	    case 2: return Const.Unit_ZergMutalisk; break; // Broodling
	    case 3: return Const.Unit_ZergDrone; break;
	    case 4: return Const.Unit_ZergDefiler; break;
	    case 5: return Const.Unit_ZergGuardian; break; // Lurker
	    case 6: return Const.Unit_ZergUltralisk; break;
	}
    return Const.Unit_None;
}

function GetNextUnitType(unitType) {
    switch(unitType) {
        case Const.Unit_ZergUltralisk: return Const.Unit_ZergGuardian; break;
        case Const.Unit_ZergGuardian: return Const.Unit_ZergDefiler; break;
        case Const.Unit_ZergDefiler: return Const.Unit_ZergDrone; break;
        case Const.Unit_ZergDrone: return Const.Unit_ZergMutalisk; break;
        case Const.Unit_ZergMutalisk: return Const.Unit_ZergZergling; break;
    }
    return Const.Unit_None;
}


function ExtractNextMobFromCurrentWave() {
	const index = 0;
	const waves = EUDArray.cast(CurrentWave);
	for (var i = Balance.TIER_COUNT; i > 0; i--) {
		if (waves[i] > 0) {
			waves[i]--;
			return GetUnitTypeForTier(i);
		} 
	}
	return Const.Unit_None;
}

function Update() {
	if (CurrentWaveID == 0) {
		return;
	}
	CurrentWaveSpawnTimer += CurrentWaveSpawnTimerIncrement;
	// setcurpl(P1); Screen.printfAt(1, "CurrentWaveSpawnTimer: {} / {}", CurrentWaveSpawnTimer, MobCountMultiplierConstant);
	// setcurpl(P1); Screen.printAt(2, "...");	
	while (CurrentWaveSpawnTimer >= MobCountMultiplierConstant) {
		// setcurpl(P1); Screen.printAt(2,"Spawn!");
		CurrentWaveSpawnTimer -= MobCountMultiplierConstant;
		const playerCount = 1; // TODO support multiple players and spawn locations
		const nextUnitType = ExtractNextMobFromCurrentWave();
		if (nextUnitType != Const.Unit_None) {
			for (var i = 0; i < playerCount; i++) {
				const unit = Utils.createUnit(nextUnitType, SpawnLocations[i], $P7);
				Unit.setStatusFlags(unit, 0x00230005); // 5xxxx does not move, 3xxxx crashes	
			}
		} else {
			// Wave ended, spawn next
			if (Command(P7, Exactly, 0, Const.Unit_AnyUnit)) {
				GoToNextWave();
			}
		}
	}
}