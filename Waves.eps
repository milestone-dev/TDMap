import ETK.ETKUnit as Unit;
import ETK.ETKUtils as Utils;
import ETK.ETKTimer as Timer;
import ETK.ETKConstants as Const;
import ETK.ETKCommon as Common;
import Balance;
import Towers;
const Screen = StringBuffer(64);

const MobCountMultiplierConstant = 1000;
const SpawnDurationConstant = 600;

const MobPlayer = $P7;
const LocationInset = 8;
const LocationSize = 8;
const TileSize = 32;

var CurrentWaveID = 1;
var CurrentWaveSpawnTimer = 0;
var CurrentWaveSpawnTimerIncrement = 0;
var CurrentWave = EUDArray(7);
var CurrentWaveReward = 0;

const UseTestWave = false;
const TestWave = [0,0,0,0,0,0,28];

// Foward declare
function StartWave(waveID);


// TODO Move to Levels.eps later
const TrackLocationFrom = $L("TrackLocation1");
const TrackLocationTo = $L("TrackLocation2");
var LevelTrackCoordinates = 0;
const Level1TrackCoordinates = [
	Common.CreatePoint(106, 35),
	Common.CreatePoint(113, 35),
	Common.CreatePoint(113, 32),
	Common.CreatePoint(110, 32),
	Common.CreatePoint(110, 41),
	Common.CreatePoint(107, 41),
	Common.CreatePoint(107, 38),
	Common.CreatePoint(118, 38),
	Common.CreatePoint(118, 32),
	Common.CreatePoint(121, 32),
	Common.CreatePoint(121, 41),
	Common.CreatePoint(113, 41),
	Common.CreatePoint(113, 44)
];

const Level2TrackCoordinates = [
	Common.CreatePoint(113, 85),
	Common.CreatePoint(113, 88),
	Common.CreatePoint(109, 88),
	Common.CreatePoint(109, 91),
	Common.CreatePoint(105, 91),
	Common.CreatePoint(105, 96),
	Common.CreatePoint(109, 96),
	Common.CreatePoint(109, 99),
	Common.CreatePoint(109, 99),
	Common.CreatePoint(113, 99),
	Common.CreatePoint(113, 99),
	Common.CreatePoint(113, 103),
	Common.CreatePoint(118, 103),
	Common.CreatePoint(118, 99),
	Common.CreatePoint(122, 99),
	Common.CreatePoint(122, 96),
	Common.CreatePoint(122, 96),
	Common.CreatePoint(126, 96),
	Common.CreatePoint(126, 91),
	Common.CreatePoint(122, 91),
	Common.CreatePoint(122, 88),
	Common.CreatePoint(118, 88),
	Common.CreatePoint(118, 85)
];

const Level3TrackCoordinates = [
	Common.CreatePoint(55, 52),
	Common.CreatePoint(73, 52)
];

const LEVEL_COUNT = 3;
const Levels = [
	Level1TrackCoordinates,
	Level2TrackCoordinates,
	Level3TrackCoordinates
];

function SetLevel(levelID) {
	if (levelID == 0) {
		return;
	}
	// Levels are 1-based
	levelID -= 1;
	if (levelID <= LEVEL_COUNT) {
		LevelTrackCoordinates = Levels[levelID];
	} else {
		LevelTrackCoordinates = 0;
	}
	StartWave(1);
}

function CalculateCurrentWaveRemainingMobs() {
	var num = 0;
	const waves = EUDArray.cast(CurrentWave);
	for (var i = Balance.TIER_COUNT; i > 0; i--) {
		num += waves[i];
	}
	return num;
}

function KillAllMobs() {
	RemoveUnit(Const.Unit_AnyUnit, MobPlayer);
}

function StartWave(waveID) {
	CurrentWaveID = waveID;
	KillAllMobs();
	Towers.ResetMobPriorty();
	if (waveID > 0) {
		// TODO Make sure array is copied, otherwise you can't replay the same wave twice
		CurrentWave = Balance.CalculateMobsForWave(CurrentWaveID); 
		if (UseTestWave) {
			CurrentWave = TestWave;
		}
		CurrentWaveSpawnTimer = MobCountMultiplierConstant;
		const remainingMobs = CalculateCurrentWaveRemainingMobs();
		CurrentWaveReward = remainingMobs;
		CurrentWaveSpawnTimerIncrement = remainingMobs * MobCountMultiplierConstant / SpawnDurationConstant;
		setcurpl(P1); Screen.printf("Starting Wave {}", waveID);
		if (remainingMobs == 0) {
			setcurpl(P1); Screen.printf("Error: Wave is empty: {}", waveID);
			CurrentWaveID = 0;
		}
	}
}

function GoToNextWave() {
	SetResources(AllPlayers, Add, CurrentWaveReward, 0);
	setcurpl(P1); Screen.printf("Wave completed! Adding {} minerals.", CurrentWaveReward);
	CurrentWaveReward = 0;
	StartWave(CurrentWaveID+1);
}

function GetUnitTypeForTier(tier) {
	switch(tier) {
		case 1: return Const.Unit_ZergZergling; break;
		case 2: return Const.Unit_ZergMutalisk; break; // Broodling
		case 3: return Const.Unit_ZergDrone; break;
		case 4: return Const.Unit_ZergDefiler; break;
		case 5: return Const.Unit_ZergGuardian; break; // Lurker
		case 6: return Const.Unit_ZergUltralisk; break;
	}
	return Const.Unit_None;
}

function GetNextUnitType(unitType) {
	switch(unitType) {
		case Const.Unit_ZergUltralisk: return Const.Unit_ZergGuardian; break;
		case Const.Unit_ZergGuardian: return Const.Unit_ZergDefiler; break;
		case Const.Unit_ZergDefiler: return Const.Unit_ZergDrone; break;
		case Const.Unit_ZergDrone: return Const.Unit_ZergMutalisk; break;
		case Const.Unit_ZergMutalisk: return Const.Unit_ZergZergling; break;
	}
	return Const.Unit_None;
}


function ExtractNextMobFromCurrentWave() {
	const index = 0;
	const waves = EUDArray.cast(CurrentWave);
	for (var i = Balance.TIER_COUNT; i > 0; i--) {
		if (waves[i] > 0) {
			waves[i]--;
			return GetUnitTypeForTier(i);
		} 
	}
	return Const.Unit_None;
}

function Update() {
	if (CurrentWaveID == 0) {
		return;
	}

	if (LevelTrackCoordinates == 0) {
		return;
	}

	// Ordering units
	const LevelTrackCoordinatesArray = EUDArray.cast(LevelTrackCoordinates);
	var endPoint;
	for (var i = 0; i < 64; i++) {
		if (LevelTrackCoordinatesArray[i] == 0 || LevelTrackCoordinatesArray[i+1] == 0) {
			break;
		}
		const p1 = Common.Point.cast(LevelTrackCoordinatesArray[i]);
		const p2 = Common.Point.cast(LevelTrackCoordinatesArray[i+1]);
		Utils.setLocationToRect(TrackLocationFrom, p1.x * TileSize + LocationInset, p1.y * TileSize + LocationInset, LocationSize, LocationSize);
		Utils.setLocationToRect(TrackLocationTo, p2.x * TileSize + LocationInset, p2.y * TileSize + LocationInset, LocationSize, LocationSize);
		endPoint = TrackLocationTo;
		Order(Const.Unit_AnyUnit, MobPlayer, TrackLocationFrom, 0, TrackLocationTo);
		// const a,b,c,d = Utils.getLocationRect(TrackLocationTo); setcurpl(P1); Screen.printf("loc TL {}x{} BR {}x{}", a,b,c,d);
	}

	// Creating units
	CurrentWaveSpawnTimer += CurrentWaveSpawnTimerIncrement;
	// setcurpl(P1); Screen.printfAt(1, "CurrentWaveSpawnTimer: {} / {}", CurrentWaveSpawnTimer, MobCountMultiplierConstant);
	const startPoint = Common.Point.cast(LevelTrackCoordinatesArray[0]);
	Utils.setLocationToRect(TrackLocationFrom, startPoint.x * TileSize + LocationInset, startPoint.y * TileSize + LocationInset, LocationSize, LocationSize);
	while (CurrentWaveSpawnTimer >= MobCountMultiplierConstant) {
		CurrentWaveSpawnTimer -= MobCountMultiplierConstant;
		const nextUnitType = ExtractNextMobFromCurrentWave();
		if (nextUnitType != Const.Unit_None) {
			const unit = Utils.createUnit(nextUnitType, TrackLocationFrom, MobPlayer);
			Unit.setStatusFlags(unit, 0x00230005); // 5xxxx does not move, 3xxxx crashes	
		} else {
			if (Command(MobPlayer, Exactly, 0, Const.Unit_AnyUnit)) {
				GoToNextWave();
			}
		}
	}

	// Removing units
	if (Bring(MobPlayer, AtLeast, 1, Const.Unit_AnyUnit, endPoint)) {
		RemoveUnitAt(1, Const.Unit_AnyUnit, endPoint, MobPlayer);
		SetResources(AllPlayers, Subtract, 1, 1);
	}
}