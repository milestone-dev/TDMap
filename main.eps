import ETK.ETKUnit as Unit;
import ETK.ETKUtils as Utils;
import ETK.ETKTimer as Timer;
import ETK.ETKConstants as Const;
import ETK.ETKCommon as Common;
import Balance;
import Waves;
import Towers;

const Screen = StringBuffer(256);
const MouseLeftButtonPress = EUDArray(6);
const MouseLeftButtonDown = EUDArray(6);
const MouseRightButtonPress = EUDArray(6);
const MouseRightButtonDown = EUDArray(6);
const KeyQDown = EUDArray(6);
const KeyPDown = EUDArray(6);
const KeyUDown = EUDArray(6);


// Debug console
const ConsoleOpen = EUDArray(6);
const KeyNumberDown = EUDArray(6);
const ConsoleCommandInput = EUDArray(6);
const ConsoleNumberInput = EUDArray(6);
const KeyENTERDown = EUDArray(6);
const KeyESCDown = EUDArray(6);
const CommandKeyDown = EUDArray(6);

const Command_Wave = 1; // W
const Command_Kill = 2; // K
const Command_Minerals = 3; // M

const PlacementLocation = $L("Placement");

// TODO replace with objects

const PlayerWeaponIndex = EUDArray(6);
const PlayerWeaponCooldown = EUDArray(6);
const PlayerSelectedUnit = EUDArray(6);

const MouseLoc = [
	$L("MouseLoc1"),
	$L("MouseLoc2"),
	$L("MouseLoc3"),
	$L("MouseLoc4"),
	$L("MouseLoc5"),
	$L("MouseLoc6")
];

const SelectionAddresses = [
	0x6284E8,
	0x628518,
	0x628548,
	0x628578,
	0x6285A8,
	0x6285D8
];


const SelectedUnitID = EUDArray(6);

function updateSelectedUnit(playerID) {
	const address = SelectionAddresses[playerID];
	const ptr = dwread(address);
	const epd = EPD(ptr);
	if (ptr != 0) {
		SelectedUnitID[playerID] = epd;
	} else {
		SelectedUnitID[playerID] = 0;
	}
}

function refreshSelection(playerID) {
	PlayerSelectedUnit[playerID] = 0;
}

function initMap() {
	EUDRegisterObjectToNamespace("MouseLeftButtonPress", MouseLeftButtonPress);
	EUDRegisterObjectToNamespace("MouseLeftButtonDown", MouseLeftButtonDown);
	EUDRegisterObjectToNamespace("MouseRightButtonPress", MouseRightButtonPress);
	EUDRegisterObjectToNamespace("MouseRightButtonDown", MouseRightButtonDown);

	EUDRegisterObjectToNamespace("KeyQDown", KeyQDown);
	EUDRegisterObjectToNamespace("KeyPDown", KeyPDown);
	EUDRegisterObjectToNamespace("KeyUDown", KeyUDown);
	

	EUDRegisterObjectToNamespace("KeyNumberDown", KeyNumberDown);
	EUDRegisterObjectToNamespace("KeyENTERDown", KeyENTERDown);
	EUDRegisterObjectToNamespace("KeyESCDown", KeyESCDown);
	EUDRegisterObjectToNamespace("CommandKeyDown", CommandKeyDown);
	Towers.load();
}

function onPluginStart() {
	randomize();
	initMap();
	Utils.setup();
}


function handleConsoleCommand(command, value, playerID) {
	switch(command) {
		case Command_Wave:
			Waves.StartWave(value);
		break;
		case Command_Kill:
			Screen.print("Killing all mobs");
			Waves.KillAllMobs();
		break;
		case Command_Minerals:
			Screen.printf("Adding {} minerals", value);
        	SetResources(playerID, 8, value, 0);
		break;
	}
}

function handleConsoleInput(playerID) {
	if (ConsoleOpen[playerID]) {
		if (CommandKeyDown[playerID] > 0) {
			ConsoleCommandInput[playerID] = CommandKeyDown[playerID];
			ConsoleNumberInput[playerID] = 0;
			// Screen.printf("ConsoleCommandInput {}", CommandKeyDown[playerID]);
		}
		if (KeyNumberDown[playerID] > 0) {
			if (KeyNumberDown[playerID] == 10) {
				KeyNumberDown[playerID] = 0;
			}
			ConsoleNumberInput[playerID] = Utils.concatenateIntegers(ConsoleNumberInput[playerID], KeyNumberDown[playerID]);
			// Screen.printf("AddN {}", KeyNumberDown[playerID]);
		}
		if (KeyENTERDown[playerID] || KeyESCDown[playerID]) {
			if (KeyENTERDown[playerID] && ConsoleCommandInput[playerID]) {
				// Screen.printf("Value {}", ConsoleNumberInput[playerID]);
				handleConsoleCommand(ConsoleCommandInput[playerID], ConsoleNumberInput[playerID], playerID);
			}
			ConsoleCommandInput[playerID] = 0;
			ConsoleNumberInput[playerID] = 0;
			ConsoleOpen[playerID] = false;
			// Screen.print("Close console");
		}
	} else {
		if (KeyENTERDown[playerID]) {
			ConsoleOpen[playerID] = true;
			// Screen.print("Open console");
		}
	}
}


function beforeTriggerExec() {
	Utils.EUDTurbo();
	Timer.tick();


	if (Switch(0, 2) && Waves.CurrentWaveID == 0) {
		Waves.StartWave(1);
	}

	Waves.Update();


	EUDPlayerLoop()();
	if (getcurpl() < $P7) {
		const playerID = getcurpl();
		updateSelectedUnit(playerID);
		const selectedUnit = SelectedUnitID[playerID];
		const mouseLocation = MouseLoc[playerID];


		handleConsoleInput(playerID);


		// TOWERS ACTIVE
		foreach(ptr, unit : EUDLoopPlayerUnit(playerID)) {
			if (Towers.isUnitTower(unit)) {
				const towerUnit = unit;

				if (Towers.isUnitUpgradedTower(towerUnit)) {
					Towers.updateTower(towerUnit);
				}

				// SELECTING TOWERS FROM BASE TOWER
				if (Towers.isUnitBaseTower(towerUnit)) {
					const queueUnitType = Unit.getBuildQueue1(towerUnit);
					if (queueUnitType != Const.Unit_None) {
						if (queueUnitType == 99) {
							Towers.sellTower(towerUnit);
							refreshSelection(playerID);
						} else {
							Towers.setTowerType(towerUnit, queueUnitType);
							Unit.clearBuildQueue(towerUnit);
							refreshSelection(playerID);
						}
					}
				} else if (Towers.isUnitUpgradedTower(towerUnit)) {
					Towers.updateTower(towerUnit);

					const queueUnitType = Unit.getBuildQueue1(towerUnit);
					if (queueUnitType != Const.Unit_None) {
						if (queueUnitType == 99) {
							Towers.sellTower(towerUnit);
							refreshSelection(playerID);
						} else {
							const tower = Towers.getTowerForUnit(towerUnit);
							// switch(queueUnitType) {
							// 	case 0: tower.applyUpgrade(10, 0, 0); break;
							// 	case 1: tower.applyUpgrade(0, 10, 0); break;
							// 	case 2: tower.applyUpgrade(0, 0, 32); break;
							// }
							refreshSelection(playerID);
						}
					}

					if (Unit.getBuildQueueLength(towerUnit) > 0) {
						Unit.clearBuildQueue(towerUnit);
					}
				}
			}
		}

		// PLACING TOWERS
		if (selectedUnit != 0 && Unit.getUnitType(selectedUnit) == Const.Unit_KhaydarinCrystalFormation) {
			if (Unit.getOrder(selectedUnit) == Const.Order_Build_SCV) {
				var x, y = Utils.getLocationPoint(MouseLoc[playerID]);
				var roundedX = ((x / 32) * 32) + 32;
				var roundedY = ((y / 32) * 32) + 32;
			    Utils.centerLocationOnPoint(PlacementLocation, roundedX, roundedY, 64, 64);
				Towers.createBaseTower(PlacementLocation, playerID);
    			Unit.setOrder(selectedUnit, Const.Order_Nothing2_Normal);
			}
		}

		// TOWERS DISPLAY
		if (Towers.isUnitTower(selectedUnit)) {
			if (PlayerSelectedUnit[playerID] != selectedUnit) {

				const tower = Towers.getTowerForUnit(selectedUnit);

				// Update display
				if (Towers.isUnitUpgradedTower(selectedUnit)) {	
					// TODO: Set up weapon per player to avoid desync
					if (IsUserCP()) {
						const weaponID = 229 + playerID;
		    			settblf(weaponID, 0, "Speed: {}\nRange: {}", tower.speed, tower.range);
						Utils.setWeaponDamage(playerID, tower.damage);
						// Utils.setWeaponIcon(weaponID, ...);
						Utils.setUnitWeapon(Towers.TowerUnitType, playerID);
					}
					// Have a unit for every player that is just there to represent the mineral cost for next upgrade
					Utils.setUnitCost(100 + playerID, 10 + Unit.getRankIncrease(selectedUnit) * 10);
				} else {
					if (IsUserCP()) {
						Utils.setUnitWeapon(Towers.TowerUnitType, 130);
					}
				}

				PlayerSelectedUnit[playerID] = selectedUnit;
				Unit.setStatusFlags(selectedUnit, 0x04340008);
				Timer.add(0, selectedUnit, EUDFuncPtr (2, 0) (function(callbackUnit, intervalCount) {
					Unit.setStatusFlags(callbackUnit, 0x04340003);
				}));
			}


			if (Towers.isUnitUpgradedTower(selectedUnit)) {
				const towerType = Towers.getTowerTypeByID(Unit.getCustomValue(selectedUnit));
				const tower = Towers.getTowerForUnit(selectedUnit);
				Towers.drawTowerRange(Unit.getPositionX(selectedUnit), Unit.getPositionY(selectedUnit), tower.range);
				Screen.printfAt(0,
					"O: Target: {}, Cooldown {} / {} -- {}",
					Towers.getTowerTarget(selectedUnit),
					Unit.getGroundWeaponCooldown(selectedUnit),
					towerType.data.baseSpeed,
					tower.damage
				);
				// Unit.setUnknown00(selectedUnit, Unit.getUnknown00(selectedUnit) + 1);
			}
		}
	}
	EUDEndPlayerLoop();

	// Missiles
	foreach(ptr, unit : EUDLoopPlayerUnit(P8)) {
		if (Unit.getUnitType(unit) == Const.Unit_ProtossObserver) {

			const targetUnit = Unit.getTargetUnit(unit);
			if (Unit.isOrderTargetUnitValid(unit)) {
				const uX, uY = Unit.getPosition(unit);
				const tX, tY = Unit.getPosition(targetUnit);
				Unit.setOrder(unit, Const.Order_Ignore_Normal);
				Unit.setOrderTargetX(unit, tX);
				Unit.setOrderTargetY(unit, tY);
				// Unit.setTargetUnit(unit, targetUnit);
				if (Utils.abs(uX-tX) < 32 && Utils.abs(uY-tY) < 32) {
					Towers.missileHit(unit);
				}
			} else {
				Utils.removeUnit(unit);
			}
		}
		if (Unit.getUnitType(unit) == Utils.OVERLAY_SPRITE_UNIT_TYPE) {
			Utils.updateOverlay(unit);
		}
	}

	foreach(ptr, unit : EUDLoopPlayerUnit(P7)) {
		if (true) {
			// TODO: Move into UpdateMob function later.
			// Hack for now, implement with timer later
			Unit.set106Flag(unit, Unit.get106Flag(unit) + 1);
			if (Unit.get106Flag(unit) > 12) {
				Unit.set106Flag(unit, 0);
				Unit.setKillCount(unit, Unit.getKillCount(unit) + 1);				
			}

			const maxHP = Unit.getMaxHitpoints(unit);
			const hp = Unit.getHitpoints(unit);
			const fraction = maxHP / 4;
			if (hp <= fraction) {
				Utils.setUnitColor(unit, $P1);
			} else if (hp <= fraction*2) {
				Utils.setUnitColor(unit, $P5);
			} else if (hp <= fraction*3) {
				Utils.setUnitColor(unit, $P8);
			} else {
				Utils.setUnitColor(unit, 8);
			}
		}
	}
}